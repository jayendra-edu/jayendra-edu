# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JKPipa-CVu9d505u6dpBsU6XMyXDzxY9

Name -  Jayendra
course = Data science with generative ai
Date  = sun, 29 sept
```
# This is formatted as code
```

Q`. Explain the purpose and advantages of Numpy in scientic computong and data analysis. How does it enhance python's for numerical operations.

Efficient Numerical Computation: At its core, NumPy provides ndarrays, which are multi-dimensional arrays optimized for storing and processing numerical data. Unlike Python lists, which can hold objects of different types, NumPy arrays enforce a single data type, leading to significant performance gains.
Vectorization: NumPy excels at "vectorized" operations. This means you can apply mathematical functions to entire arrays without writing explicit loops, making your code concise and fast.
Broadcasting: NumPy's broadcasting rules simplify operations between arrays of different shapes (under certain conditions) without manual resizing.
Foundation for Scientific Libraries: NumPy serves as the cornerstone for libraries like pandas (data manipulation), SciPy (scientific computing), Matplotlib (plotting), and many others.
"""

from google.colab import drive
drive.mount('/content/drive')



"""Q2. Compare and contrast np.mean() and np.average() in numpy.. when would you use one over the other?

np.mean(): Calculates the arithmetic mean (average) of array elements.
np.average(): Offers more flexibility by allowing weighted averages. If no weights are provided, it behaves like np.mean().
"""

import numpy as np

data = np.array([1, 2, 3, 4, 5])
mean = np.mean(data)
weighted_avg = np.average(data, weights=[1, 2, 1, 1, 2])  # Gives more importance to elements at index 1 and 4

"""Q3. Describe the methods for reversing a numpy array along different axes. provides examples for 1D and 2D arrays.

You can reverse NumPy arrays along different axes using slicing and np.flip():
"""

import numpy as np

arr_1d = np.array([1, 2, 3, 4])
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6]])

reversed_1d = arr_1d[::-1]
reversed_2d_rows = arr_2d[::-1, :]  # Reverse rows
reversed_2d_cols = arr_2d[:, ::-1]  # Reverse columns
fully_reversed = np.flip(arr_2d)     # Reverse both rows and columns

"""Q4. How can you determine the data type of elements in a numpy array? Discuss the importance of data types in memory managemen and performance.

dtype Attribute: Use the dtype attribute to check the data type of array elements (e.g., arr.dtype). Common data types include int32, float64, bool, etc.
Memory Management: Choosing the right data type helps optimize memory usage. For instance, storing small integers in int8 instead of int32 reduces memory consumption.
Performance: Operations on arrays with appropriate data types are generally faster.

Q5. Define ndarys in numpy and explain their key features. how do they differ from standard lists?

(feature)
memory
performance
mutability

ndarray
Homogeneous (all elements of the same type)
Contiguous block for efficiency
Optimized for numerical operations
Elements can be modified

 python list
 Heterogeneous (can mix types)
 	Scattered memory locations
  Slower for numerical tasks
  Elements can be modified

Q6. Analyze the performance benefits of numpy arrays over python lists for large-scale numerical operartions.

Contiguous Memory: NumPy's contiguous memory layout allows for faster access and manipulation of data compared to Python lists.
Vectorization: Eliminates the overhead of Python loops, leading to substantial speedups for repetitive calculations.
Hardware Optimization: NumPy leverages optimized libraries (like BLAS and LAPACK) written in lower-level languages (C/Fortran) to take advantage of your computer's hardware.

Q7. Compare vstack() and hstack() functions in numpy. provide examples demonstratuing their usage and output.

vstack() (vertical stack): Stacks arrays vertically (rows on top of each other). Arrays must have the same number of columns.
hstack() (horizontal stack): Stacks arrays horizontally (side by side). Arrays must have the same number of rows.
python
"""

import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

vertical_stack = np.vstack((arr1, arr2))
horizontal

"""Q8. Explain the differnces between flipir() and flipiud () methods in numpy,including their effects on various array dimensions.

fliplr(array): Flips an array horizontally (left to right) along the vertical axis (axis=1 by default).
Imagine looking at the array in a mirror.
flipud(array): Flips an array vertically (upside down) along the horizontal axis (axis=0 by default).
"""

import numpy as np

arr = np.array([[1, 2, 3],
                [4, 5, 6]])

flipped_lr = np.fliplr(arr)
flipped_ud = np.flipud(arr)

print("Original:")
print(arr)
print("\nFlipped Left-Right:")
print(flipped_lr)
print("\nFlipped Up-Down:")
print(flipped_ud)

"""Q9. Discuss the functionality of the array_split() method in Numpy. How does it handle uneven splits?

Purpose: Divides an array into multiple sub-arrays.

Flexibility: array_split() is more flexible than split() because it handles uneven splits gracefully.

Syntax: np.array_split(array, indices_or_sections, axis=0)

array: The input array to split.
indices_or_sections:
If an integer (N), the array is divided into N equal-sized sub-arrays (as evenly as possible).
If a list of indices, the array is split at the specified indices.
axis: The axis along which to split the array (default is 0).
"""

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7])

# Split into 3 equal-sized sub-arrays
split_arrays = np.array_split(arr, 3)
print(split_arrays)

# Split at specific indices
split_arrays_at_indices = np.array_split(arr, [2, 5])
print(split_arrays_at_indices)

"""Q10 Explain the concepts of vectorisation and broaadcasting in numpy. how they contribute to efficient array operations?

Vectorization

Concept: Performing operations on entire arrays (or large chunks of data) instead of looping through individual elements.
Benefits:
Speed: NumPy's underlying C implementation makes vectorized operations significantly faster than Python loops, especially for large datasets.
Conciseness: Vectorized code is often more readable and easier to understand.
Example:
"""

import numpy as np

# Without vectorization (slow)
data = [1, 2, 3, 4, 5]
result = []
for x in data:
    result.append(x * 2)

# With vectorization (fast)
data_np = np.array(data)
result_np = data_np * 2

"""Broadcasting

Concept: NumPy's mechanism for performing operations on arrays of different shapes, as long as their dimensions are compatible. Broadcasting effectively "stretches" the smaller array to match the shape of the larger one.
Rules:
If the arrays don't have the same number of dimensions, prepend the shape of the smaller array with ones until both shapes have the same length.
The dimensions are compatible if they are equal or one of them is 1.
Example:
"""

import numpy as np

arr1 = np.array([[1, 2, 3],
                 [4, 5, 6]])

arr2 = np.array([10, 20, 30])

result = arr1 + arr2  # Broadcasting happens here
print(result)

[[11 22 33]
 [14 25 36

practical Questions

# 1. Create a 3x3 NumPy array with random integers between 1 and 100. Then, interchange its rows and columns.

array_1 = np.random.randint(1, 101, size=(3, 3))
print("Original array:")
print(array_1)
print("Transposed array:")
print(array_1.T)

# 2. Generate a 1D NumPy array with 10 elements. Reshape it into a 2x5 array, then into a 5x2 array.

array_2 = np.arange(10)
print("\nOriginal 1D array:")
print(array_2)
print("Reshaped to 2x5:")
print(array_2.reshape(2, 5))
print("Reshaped to 5x2:")
print(array_2.reshape(5, 2))

# 3. Create a 4x4 NumPy array with random float values. Add a border of zeros around it, resulting in a 6x6 array.

array_3 = np.random.rand(4, 4)
print("\nOriginal 4x4 array:")
print(array_3)
array_3_padded = np.zeros((6, 6))
array_3_padded[1:-1, 1:-1] = array_3
print("Padded 6x6 array:")
print(array_3_padded)

4. Using NumPy, create an array of integers from 10 to 60 with a step of 5.

array_4 = np.arange(10, 61, 5)
print("\nArray from 10 to 60 with step 5:")
print(array_4)

5. Create a NumPy array of strings ['python', 'numpy', 'pandas']. Apply different case transformations (uppercase, lowercase, title case, etc.) to each element.

array_5 = np.array(['python', 'numpy', 'pandas'])
print("\nOriginal array:")
print(array_5)
print("Uppercase:")
print(np.char.upper(array_5))
print("Lowercase:")
print(np.char.lower(array_5))
print("Title case:")
print(np.char.title(array_5))

# 6. Generate a NumPy array of words. Insert a space between each character of every word in the array.

array_6 = np.array(['This', 'is', 'a', 'NumPy', 'array'])
print("\nOriginal array:")
print(array_6)
array_6_spaced = np.array([' '.join(list(word)) for word in array_6])
print("Array with spaces:")
print(array_6_spaced)

# 7. Create two 2D NumPy arrays and perform element-wise addition, subtraction, multiplication, and division.

array_7a = np.random.randint(1, 10, size=(2, 2))
array_7b = np.random.randint(1, 10, size=(2, 2))
print("\nArray 7a:")
print(array_7a)
print("Array 7b:")
print(array_7b)
print("Addition:")
print(array_7a + array_7b)
print("Subtraction:")
print(array_7a - array_7b)
print("Multiplication:")
print(array_7a * array_7b)
print("Division:")
print(array_7a / array_7b)

# 8. Use NumPy to create a 5x5 identity matrix, then extract its diagonal elements.

identity_matrix = np.eye(5)
print("\n5x5 identity matrix:")
print(identity_matrix)
print("Diagonal elements:")
print(np.diag(identity_matrix))

# 9. Generate a NumPy array of 100 random integers between 0 and 1000. Find and display all prime numbers in this array.

def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

array_9 = np.random.randint(0, 1001, size=100)
print("\nRandom array:")

# Q10create a numpy array representing daily temperatures for a mouth . Calculate and display the weekly averages.

import numpy as np

# Generate random daily temperatures for a month (30 days)
daily_temperatures = np.random.uniform(10, 25, 30)
print("Daily Temperatures:")
print(daily_temperatures)

